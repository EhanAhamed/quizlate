require("dotenv").config();
const Fastify = require("fastify");
const fastifyCookie = require("@fastify/cookie");
const fastifyCors = require("@fastify/cors");
const fastifyPostgres = require("@fastify/postgres");
const path = require("node:path");

const port = process.env.PORT;
const host = process.env.HOST;
const pgConnection = process.env.POSTGRES_URI;
const corsOrigin = process.env.CORS_ORIGIN;
const cookiesDomain = process.env.COOKIES_DOMAIN;
const logLevel = process.env.LOG_LEVEL;

const fastify = Fastify({
    logger: {
        level: logLevel,
        file: path.join(__dirname, "logfile.log")
    }
})

fastify.register(fastifyCors, {
    origin: corsOrigin
})
fastify.register(fastifyCookie)
fastify.register(fastifyPostgres, {
    connectionString: pgConnection
})

function cookieOptions() {
    let time = new Date();
    /* 7 days * 24h * 60m * 60s = 8640000 sec for 100 days */
    time.setSeconds(time.getSeconds() + 604800)
    return {
        domain: cookiesDomain,
        path: "/",
        signed: false,
        expires: time,
        maxAge: 604800,
        httpOnly: true,
        sameSite: "lax",
        /* when secure is true,
        browsers only send the cookie through https,
        on localhost, browsers send it even if localhost isn't using https */
        secure: true
    }
}

function clearExpiredSessions() {
    fastify.pg.query(
        "delete from auth.sessions where expire_at < clock_timestamp()",
        [],
        function (error, result) {
            if (error) {
                fastify.log.error(error);
            }
        }
    )
}

function newSessionCookie(request, reply, userId) {
    /* sets session cookie on reply object,
    it sets the cookie and returns true
    or logs an error and returns false */
    clearExpiredSessions()
    fastify.pg.query(
        "insert into auth.sessions (user_id) " +
        "values ($1) returning token",
        [userId],
        function (error, result) {
            if (error) {
                request.log.error(error);
                return false;
            } else {
                reply.setCookie(
                    "session",
                    result.rows[0].token,
                    cookieOptions()
                )
                return true;
            }
        }
    )
}

fastify.post("/sign-up", function (request, reply) {
    /* check if username and password were sent in sign-up request body */
    if (request.body && request.body.username && request.body.password) {
        let username = request.body.username;
        /* regex to check if username has letters or numbers (any alphabet) or dot, underscore, or dash */
        if (/^[\p{L}\p{N}\p{M}._-]+$/u.test(username) && username.length >= 2 && username.length < 100) {
            fastify.pg.query(
                /* check if username already taken */
                "select username from auth.users where username = $1 limit 1",
                [username],
                function (error, result) {
                    if (error) {
                        request.log.error(error)
                        reply.status(500).send({
                            error: {
                                type: "postgres-error"
                            }
                        })
                    } else {
                        if (result.rowCount = 1) {
                            /* if the query returned a row, this username is already taken */
                            reply.status(400).send({
                                error: {
                                    type: "username-taken"
                                }
                            })
                        } else {
                            /* if it didn't return 1 row (its either 1 or 0, because the query had "...limit 1",
                            then this username is okay */
                            if (request.body.password.length >= 8) {
                                fastify.pg.query(
                                    "insert into auth.users (username, encrypted_password, display_name) " +
                                    "values ($1, crypt($2, gen_salt('bf')), $1) returning id",
                                    [username, request.body.password],
                                    function (error, result) {
                                        if (error) {
                                            request.log.error(error)
                                            reply.status(500).send({
                                                error: {
                                                    type: "postgres-error"
                                                }
                                            })
                                        } else {
                                            /* user_id was generated by postgres when the user was added,
                                            now we send data including the id in the response below */
                                            let userId = result.rows[0].id;
                                            if (newSessionCookie(request, reply, userId)) {
                                                /* use newSessionCookie() func inside if statement,
                                                it returns true if the cookie was set,
                                                or returns false after logging any errors */
                                                reply.send({
                                                    error: false,
                                                    data: {
                                                        user: {
                                                            id: userId,
                                                            username: username,
                                                            display_name: username
                                                        }
                                                    }
                                                })
                                            } else {
                                                reply.send({
                                                    error: {
                                                        type: "postgres-error"
                                                    }
                                                })
                                            }
                                        }
                                    }
                                )
                            } else {
                                /* password does not match length */
                                reply.status(400).send({
                                    error: {
                                        type: "password-weak"
                                    }
                                })
                            }
                        }
                    }
                }
            )
        } else {
            /* username does not match regex or does not match length */
            reply.status(400).send(
                {
                    error: {
                        type: "username-invalid"
                    }
                }
            )
        }
    } else {
        /* password and/or username missing in request.body */
        reply.status(400).send({
            error: {
                type: "fields-missing"
            }
        })
    }
})

fastify.post("/sign-in", function (request, reply) {
    if (request.body && request.body.username && request.body.password) {
        fastify.pg.query(
            "select id, username, display_name from auth.users " +
            "where username = $1 and encrypted_password = crypt($2, encrypted_password) limit 1",
            [request.body.username, request.body.password],
            function (error, result) {
                if (error) {
                    request.log.error(error);
                    reply.status(500).send({
                        error: {
                            type: "postgres-error"
                        }
                    })
                } else {
                    if (result.rowCount = 1) {
                        if (newSessionCookie(request, reply, result.rows[0].id)) {
                            /* if newSessionCookie() returns true, no error, so send data */
                            reply.send({
                                "error": false,
                                "data": {
                                    user: result.rows[0],
                                }
                            })
                        } else {
                            /* else newSessionCookie() logged an error and returned false, so send error */
                            reply.send({
                                error: {
                                    type: "postgres-error"
                                }
                            })
                        }
                    } else {
                        /* result successful, but rowCount isn't 1,
                        the query above used limit 1, so if it's not 1, its 0,
                        if no rows are returned, then the username or password is wrong */
                        reply.send({
                            error: {
                                type: "sign-in-incorrect"
                            }
                        })
                    }
                }
            }
        )
    } else {
        /* password and/or username missing in request.body */
        reply.status(400).send({
            error: {
                type: "fields-missing"
            }
        })
    }
})

fastify.get("/studysets/public/:studyset", function (request, reply) {
    fastify.pg.query(
        "SELECT id, user_id, title, data, updated_at FROM studysets " +
        "WHERE private = false and id = $1",
        [request.params.studyset],
        function (error, result) {
            if (error) {
                request.log.error(error);
                reply.status(500).send({
                    error: {
                        type: "postgres-error"
                    }
                })
            } else {
                reply.send({
                    error: false,
                    data: {
                        studyset: result.rows[0]
                    }
                })
            }
        }
    )
})

fastify.listen({
    port: port,
    host: host
})
